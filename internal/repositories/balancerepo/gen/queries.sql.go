// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gen

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const completeDepositSession = `-- name: CompleteDepositSession :exec
UPDATE deposit_sessions
SET
    status = $1,
    metadata = $2,
    error_message = COALESCE($3, error_message),
    updated_at = CURRENT_TIMESTAMP
WHERE session_id = $4
`

type CompleteDepositSessionParams struct {
	Status       DepositSessionStatus  `json:"status"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	ErrorMessage sql.NullString        `json:"error_message"`
	SessionID    string                `json:"session_id"`
}

func (q *Queries) CompleteDepositSession(ctx context.Context, arg CompleteDepositSessionParams) error {
	_, err := q.db.ExecContext(ctx, completeDepositSession,
		arg.Status,
		arg.Metadata,
		arg.ErrorMessage,
		arg.SessionID,
	)
	return err
}

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
) VALUES (
    gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
)
`

type CreateTransactionParams struct {
	DepositSessionID sql.NullString        `json:"deposit_session_id"`
	WithdrawalID     sql.NullString        `json:"withdrawal_id"`
	ChainID          string                `json:"chain_id"`
	Network          string                `json:"network"`
	CryptoCurrency   string                `json:"crypto_currency"`
	TxHash           string                `json:"tx_hash"`
	FromAddress      string                `json:"from_address"`
	ToAddress        string                `json:"to_address"`
	Amount           string                `json:"amount"`
	UsdAmountCents   sql.NullInt64         `json:"usd_amount_cents"`
	ExchangeRate     sql.NullString        `json:"exchange_rate"`
	Fee              sql.NullString        `json:"fee"`
	BlockNumber      sql.NullInt64         `json:"block_number"`
	BlockHash        sql.NullString        `json:"block_hash"`
	Status           string                `json:"status"`
	Confirmations    int32                 `json:"confirmations"`
	Timestamp        sql.NullTime          `json:"timestamp"`
	VerifiedAt       sql.NullTime          `json:"verified_at"`
	Processor        Processortype         `json:"processor"`
	TransactionType  string                `json:"transaction_type"`
	Metadata         pqtype.NullRawMessage `json:"metadata"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.DepositSessionID,
		arg.WithdrawalID,
		arg.ChainID,
		arg.Network,
		arg.CryptoCurrency,
		arg.TxHash,
		arg.FromAddress,
		arg.ToAddress,
		arg.Amount,
		arg.UsdAmountCents,
		arg.ExchangeRate,
		arg.Fee,
		arg.BlockNumber,
		arg.BlockHash,
		arg.Status,
		arg.Confirmations,
		arg.Timestamp,
		arg.VerifiedAt,
		arg.Processor,
		arg.TransactionType,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :execrows
UPDATE transactions SET
    status = 'deleted',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTransaction, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBalance = `-- name: GetBalance :one
SELECT id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at FROM balances
WHERE user_id = $1 AND currency_code = $2
`

type GetBalanceParams struct {
	UserID       uuid.UUID `json:"user_id"`
	CurrencyCode string    `json:"currency_code"`
}

func (q *Queries) GetBalance(ctx context.Context, arg GetBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, getBalance, arg.UserID, arg.CurrencyCode)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingTransactions = `-- name: GetPendingTransactions :many
SELECT
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
FROM transactions
WHERE status IN ('pending', 'processing')
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingTransactions(ctx context.Context, limit int32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getPendingTransactions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.DepositSessionID,
			&i.WithdrawalID,
			&i.ChainID,
			&i.Network,
			&i.CryptoCurrency,
			&i.TxHash,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.UsdAmountCents,
			&i.ExchangeRate,
			&i.Fee,
			&i.BlockNumber,
			&i.BlockHash,
			&i.Status,
			&i.Confirmations,
			&i.Timestamp,
			&i.VerifiedAt,
			&i.Processor,
			&i.TransactionType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByHash = `-- name: GetTransactionByHash :one
SELECT
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
FROM transactions
WHERE chain_id = $1 AND tx_hash = $2
`

type GetTransactionByHashParams struct {
	ChainID string `json:"chain_id"`
	TxHash  string `json:"tx_hash"`
}

func (q *Queries) GetTransactionByHash(ctx context.Context, arg GetTransactionByHashParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByHash, arg.ChainID, arg.TxHash)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.DepositSessionID,
		&i.WithdrawalID,
		&i.ChainID,
		&i.Network,
		&i.CryptoCurrency,
		&i.TxHash,
		&i.FromAddress,
		&i.ToAddress,
		&i.Amount,
		&i.UsdAmountCents,
		&i.ExchangeRate,
		&i.Fee,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Status,
		&i.Confirmations,
		&i.Timestamp,
		&i.VerifiedAt,
		&i.Processor,
		&i.TransactionType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.DepositSessionID,
		&i.WithdrawalID,
		&i.ChainID,
		&i.Network,
		&i.CryptoCurrency,
		&i.TxHash,
		&i.FromAddress,
		&i.ToAddress,
		&i.Amount,
		&i.UsdAmountCents,
		&i.ExchangeRate,
		&i.Fee,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Status,
		&i.Confirmations,
		&i.Timestamp,
		&i.VerifiedAt,
		&i.Processor,
		&i.TransactionType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionStats = `-- name: GetTransactionStats :one
SELECT
    COUNT(*) as total_transactions,
    COUNT(CASE WHEN status = 'verified' THEN 1 END) as verified_count,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_count,
    COALESCE(SUM(CAST(amount AS NUMERIC)), 0) as total_amount,
    COALESCE(AVG(confirmations), 0) as avg_confirmations
FROM transactions
WHERE chain_id = $1
`

type GetTransactionStatsRow struct {
	TotalTransactions int64       `json:"total_transactions"`
	VerifiedCount     int64       `json:"verified_count"`
	PendingCount      int64       `json:"pending_count"`
	FailedCount       int64       `json:"failed_count"`
	ProcessingCount   int64       `json:"processing_count"`
	TotalAmount       interface{} `json:"total_amount"`
	AvgConfirmations  interface{} `json:"avg_confirmations"`
}

func (q *Queries) GetTransactionStats(ctx context.Context, chainID string) (GetTransactionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionStats, chainID)
	var i GetTransactionStatsRow
	err := row.Scan(
		&i.TotalTransactions,
		&i.VerifiedCount,
		&i.PendingCount,
		&i.FailedCount,
		&i.ProcessingCount,
		&i.TotalAmount,
		&i.AvgConfirmations,
	)
	return i, err
}

const getTransactionsByAddress = `-- name: GetTransactionsByAddress :many
SELECT
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
FROM transactions
WHERE chain_id = $1 AND (from_address = $2 OR to_address = $2)
ORDER BY timestamp DESC
LIMIT $3 OFFSET $4
`

type GetTransactionsByAddressParams struct {
	ChainID     string `json:"chain_id"`
	FromAddress string `json:"from_address"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetTransactionsByAddress(ctx context.Context, arg GetTransactionsByAddressParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByAddress,
		arg.ChainID,
		arg.FromAddress,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.DepositSessionID,
			&i.WithdrawalID,
			&i.ChainID,
			&i.Network,
			&i.CryptoCurrency,
			&i.TxHash,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.UsdAmountCents,
			&i.ExchangeRate,
			&i.Fee,
			&i.BlockNumber,
			&i.BlockHash,
			&i.Status,
			&i.Confirmations,
			&i.Timestamp,
			&i.VerifiedAt,
			&i.Processor,
			&i.TransactionType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT
    id, deposit_session_id, withdrawal_id, chain_id, network, crypto_currency,
    tx_hash, from_address, to_address, amount, usd_amount_cents, exchange_rate,
    fee, block_number, block_hash, status, confirmations, timestamp,
    verified_at, processor, transaction_type, metadata, created_at, updated_at
FROM transactions
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetTransactionsByStatus(ctx context.Context, arg GetTransactionsByStatusParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.DepositSessionID,
			&i.WithdrawalID,
			&i.ChainID,
			&i.Network,
			&i.CryptoCurrency,
			&i.TxHash,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.UsdAmountCents,
			&i.ExchangeRate,
			&i.Fee,
			&i.BlockNumber,
			&i.BlockHash,
			&i.Status,
			&i.Confirmations,
			&i.Timestamp,
			&i.VerifiedAt,
			&i.Processor,
			&i.TransactionType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBalances = `-- name: GetUserBalances :many
SELECT id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at FROM balances
WHERE user_id = $1
`

func (q *Queries) GetUserBalances(ctx context.Context, userID uuid.UUID) ([]Balance, error) {
	rows, err := q.db.QueryContext(ctx, getUserBalances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Balance{}
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CurrencyCode,
			&i.AmountCents,
			&i.AmountUnits,
			&i.ReservedCents,
			&i.ReservedUnits,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositSessions = `-- name: ListPendingDepositSessions :many
SELECT id, session_id, user_id, chain_id, network, wallet_address, amount, crypto_currency, status, qr_code_data, payment_link, metadata, error_message, created_at, updated_at FROM deposit_sessions
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPendingDepositSessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingDepositSessions(ctx context.Context, arg ListPendingDepositSessionsParams) ([]DepositSession, error) {
	rows, err := q.db.QueryContext(ctx, listPendingDepositSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DepositSession{}
	for rows.Next() {
		var i DepositSession
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.ChainID,
			&i.Network,
			&i.WalletAddress,
			&i.Amount,
			&i.CryptoCurrency,
			&i.Status,
			&i.QrCodeData,
			&i.PaymentLink,
			&i.Metadata,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingWithdrawals = `-- name: ListPendingWithdrawals :many
SELECT id, user_id, admin_id, withdrawal_id, chain_id, network, crypto_currency, usd_amount_cents, crypto_amount, exchange_rate, fee_cents, to_address, tx_hash, status, requires_admin_review, admin_review_deadline, processed_by_system, source_wallet_address, amount_reserved_cents, reservation_released, reservation_released_at, metadata, created_at, updated_at FROM withdrawals
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPendingWithdrawalsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingWithdrawals(ctx context.Context, arg ListPendingWithdrawalsParams) ([]Withdrawal, error) {
	rows, err := q.db.QueryContext(ctx, listPendingWithdrawals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AdminID,
			&i.WithdrawalID,
			&i.ChainID,
			&i.Network,
			&i.CryptoCurrency,
			&i.UsdAmountCents,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.FeeCents,
			&i.ToAddress,
			&i.TxHash,
			&i.Status,
			&i.RequiresAdminReview,
			&i.AdminReviewDeadline,
			&i.ProcessedBySystem,
			&i.SourceWalletAddress,
			&i.AmountReservedCents,
			&i.ReservationReleased,
			&i.ReservationReleasedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logBalanceChange = `-- name: LogBalanceChange :exec
INSERT INTO balance_logs (
    id, user_id, component, currency_code, change_cents, change_units,
    description, timestamp, balance_after_cents, balance_after_units,
    transaction_id, status
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type LogBalanceChangeParams struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	Component         Components     `json:"component"`
	CurrencyCode      string         `json:"currency_code"`
	ChangeCents       int64          `json:"change_cents"`
	ChangeUnits       string         `json:"change_units"`
	Description       sql.NullString `json:"description"`
	Timestamp         sql.NullTime   `json:"timestamp"`
	BalanceAfterCents sql.NullInt64  `json:"balance_after_cents"`
	BalanceAfterUnits sql.NullString `json:"balance_after_units"`
	TransactionID     sql.NullString `json:"transaction_id"`
	Status            sql.NullString `json:"status"`
}

func (q *Queries) LogBalanceChange(ctx context.Context, arg LogBalanceChangeParams) error {
	_, err := q.db.ExecContext(ctx, logBalanceChange,
		arg.ID,
		arg.UserID,
		arg.Component,
		arg.CurrencyCode,
		arg.ChangeCents,
		arg.ChangeUnits,
		arg.Description,
		arg.Timestamp,
		arg.BalanceAfterCents,
		arg.BalanceAfterUnits,
		arg.TransactionID,
		arg.Status,
	)
	return err
}

const releaseReservedBalance = `-- name: ReleaseReservedBalance :exec
UPDATE balances
SET
    reserved_cents = reserved_cents - $3,
    amount_cents = amount_cents + $3,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND currency_code = $2 AND reserved_cents >= $3
`

type ReleaseReservedBalanceParams struct {
	UserID        uuid.UUID     `json:"user_id"`
	CurrencyCode  string        `json:"currency_code"`
	ReservedCents sql.NullInt64 `json:"reserved_cents"`
}

func (q *Queries) ReleaseReservedBalance(ctx context.Context, arg ReleaseReservedBalanceParams) error {
	_, err := q.db.ExecContext(ctx, releaseReservedBalance, arg.UserID, arg.CurrencyCode, arg.ReservedCents)
	return err
}

const reserveBalance = `-- name: ReserveBalance :exec
UPDATE balances
SET reserved_cents = reserved_cents + $3,
    amount_cents = amount_cents - $3,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND currency_code = $2 AND amount_cents >= $3
`

type ReserveBalanceParams struct {
	UserID        uuid.UUID     `json:"user_id"`
	CurrencyCode  string        `json:"currency_code"`
	ReservedCents sql.NullInt64 `json:"reserved_cents"`
}

func (q *Queries) ReserveBalance(ctx context.Context, arg ReserveBalanceParams) error {
	_, err := q.db.ExecContext(ctx, reserveBalance, arg.UserID, arg.CurrencyCode, arg.ReservedCents)
	return err
}

const updateBalance = `-- name: UpdateBalance :exec
UPDATE balances
SET
    amount_cents = $3,
    amount_units = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND currency_code = $2
`

type UpdateBalanceParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	CurrencyCode string         `json:"currency_code"`
	AmountCents  sql.NullInt64  `json:"amount_cents"`
	AmountUnits  sql.NullString `json:"amount_units"`
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance,
		arg.UserID,
		arg.CurrencyCode,
		arg.AmountCents,
		arg.AmountUnits,
	)
	return err
}

const updateDepositSessionStatus = `-- name: UpdateDepositSessionStatus :exec
UPDATE deposit_sessions
SET
    status = $2,
    error_message = COALESCE($3, error_message),
    updated_at = CURRENT_TIMESTAMP
WHERE session_id = $1
`

type UpdateDepositSessionStatusParams struct {
	SessionID    string               `json:"session_id"`
	Status       DepositSessionStatus `json:"status"`
	ErrorMessage sql.NullString       `json:"error_message"`
}

func (q *Queries) UpdateDepositSessionStatus(ctx context.Context, arg UpdateDepositSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateDepositSessionStatus, arg.SessionID, arg.Status, arg.ErrorMessage)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :execrows
UPDATE transactions SET
    deposit_session_id = $2, withdrawal_id = $3, chain_id = $4,
    network = $5, crypto_currency = $6, tx_hash = $7,
    from_address = $8, to_address = $9, amount = $10,
    usd_amount_cents = $11, exchange_rate = $12, fee = $13,
    block_number = $14, block_hash = $15, status = $16,
    confirmations = $17, timestamp = $18, verified_at = $19,
    processor = $20, transaction_type = $21, metadata = $22,
    updated_at = $23
WHERE id = $1
`

type UpdateTransactionParams struct {
	ID               uuid.UUID             `json:"id"`
	DepositSessionID sql.NullString        `json:"deposit_session_id"`
	WithdrawalID     sql.NullString        `json:"withdrawal_id"`
	ChainID          string                `json:"chain_id"`
	Network          string                `json:"network"`
	CryptoCurrency   string                `json:"crypto_currency"`
	TxHash           string                `json:"tx_hash"`
	FromAddress      string                `json:"from_address"`
	ToAddress        string                `json:"to_address"`
	Amount           string                `json:"amount"`
	UsdAmountCents   sql.NullInt64         `json:"usd_amount_cents"`
	ExchangeRate     sql.NullString        `json:"exchange_rate"`
	Fee              sql.NullString        `json:"fee"`
	BlockNumber      sql.NullInt64         `json:"block_number"`
	BlockHash        sql.NullString        `json:"block_hash"`
	Status           string                `json:"status"`
	Confirmations    int32                 `json:"confirmations"`
	Timestamp        sql.NullTime          `json:"timestamp"`
	VerifiedAt       sql.NullTime          `json:"verified_at"`
	Processor        Processortype         `json:"processor"`
	TransactionType  string                `json:"transaction_type"`
	Metadata         pqtype.NullRawMessage `json:"metadata"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTransaction,
		arg.ID,
		arg.DepositSessionID,
		arg.WithdrawalID,
		arg.ChainID,
		arg.Network,
		arg.CryptoCurrency,
		arg.TxHash,
		arg.FromAddress,
		arg.ToAddress,
		arg.Amount,
		arg.UsdAmountCents,
		arg.ExchangeRate,
		arg.Fee,
		arg.BlockNumber,
		arg.BlockHash,
		arg.Status,
		arg.Confirmations,
		arg.Timestamp,
		arg.VerifiedAt,
		arg.Processor,
		arg.TransactionType,
		arg.Metadata,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :execrows
UPDATE transactions SET
    status = $2,
    verified_at = $3,
    metadata = COALESCE($4, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTransactionStatusParams struct {
	ID         uuid.UUID             `json:"id"`
	Status     string                `json:"status"`
	VerifiedAt sql.NullTime          `json:"verified_at"`
	Metadata   pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTransactionStatus,
		arg.ID,
		arg.Status,
		arg.VerifiedAt,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWithdrawal = `-- name: UpdateWithdrawal :exec
UPDATE withdrawals
SET
    tx_hash = COALESCE($1, tx_hash),
    status = COALESCE($2, status),
    updated_at = CURRENT_TIMESTAMP
WHERE withdrawal_id = $3
`

type UpdateWithdrawalParams struct {
	TxHash       sql.NullString   `json:"tx_hash"`
	Status       WithdrawalStatus `json:"status"`
	WithdrawalID string           `json:"withdrawal_id"`
}

func (q *Queries) UpdateWithdrawal(ctx context.Context, arg UpdateWithdrawalParams) error {
	_, err := q.db.ExecContext(ctx, updateWithdrawal, arg.TxHash, arg.Status, arg.WithdrawalID)
	return err
}
